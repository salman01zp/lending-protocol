# Miden Lending Protocol - Implementation Guide

Based on analysis of `/Users/salman/Limo-tools/miden-bridge-mono/miden`, here's how to properly implement our lending/borrowing application using Miden patterns.

## Project Structure

```
client/
├── src/
│   ├── asm/                    # MASM source code (compile-time)
│   │   ├── contracts/          # Account component libraries
│   │   │   ├── lending_pool.masm
│   │   │   ├── user_lending.masm
│   │   │   └── price_oracle.masm
│   │   ├── note_scripts/       # Transaction scripts
│   │   │   ├── deposit.masm
│   │   │   ├── borrow.masm
│   │   │   └── liquidate.masm
│   │   └── events/             # Event handlers (optional)
│   ├── accounts/               # Rust account builders
│   │   ├── mod.rs
│   │   ├── lending_pool.rs     # LendingPoolAccount component
│   │   ├── user_lending.rs     # UserLendingAccount component
│   │   └── price_oracle.rs     # PriceOracleAccount component
│   ├── notes/                  # Note helpers
│   │   └── mod.rs
│   ├── errors/                 # Auto-generated from MASM
│   │   ├── mod.rs
│   │   └── lending_errors.rs   # Generated by build.rs
│   └── lib.rs
├── tests/
│   └── integration_tests.rs    # Using MockChain
├── build.rs                    # Compiles MASM to binaries
└── Cargo.toml
```

## Implementation Steps

### 1. Update Cargo.toml

Add proper Miden dependencies following the bridge example:

```toml
[package]
name = "miden-lending-client"
version = "0.1.0"
edition = "2021"

[lib]

[features]
default = ["std"]
std = ["miden-objects/std", "miden-lib/std", "miden-tx/std"]
testing = ["miden-objects/testing", "miden-tx/testing", "miden-lib/testing"]

[dependencies]
miden-lib = { version = "0.11.4", default-features = false }
miden-objects = { version = "0.11.4", default-features = false }
miden-stdlib = { version = "0.18", default-features = false }
miden-tx = { version = "0.11.4", default-features = false }
miden-assembly = { version = "0.18", default-features = false }
thiserror = "2.0"
anyhow = "1.0"
hex = { version = "0.4", default-features = false }

[dev-dependencies]
miden-testing = { version = "0.11.4", features = ["std"] }
vm-processor = { package = "miden-processor", version = "0.18.0" }

[build-dependencies]
regex = "1.10"
walkdir = "2.5"
miden-assembly = { version = "0.18", default-features = false }
miden-objects = { version = "0.11.4", default-features = false }
miden-lib = { version = "0.11.4", default-features = false }
```

### 2. Create build.rs

Compile MASM files at build time (similar to miden-bridge):

```rust
use std::{env, fs, path::Path};
use miden_assembly::Assembler;
use miden_lib::transaction::TransactionKernel;

fn main() -> anyhow::Result<()> {
    println!("cargo:rerun-if-changed=src/asm");

    let build_dir = env::var("OUT_DIR")?;
    let source_dir = Path::new("src/asm/contracts");
    let target_dir = Path::new(&build_dir).join("assets/contracts");

    fs::create_dir_all(&target_dir)?;

    // Compile MASM files to MASL libraries
    let assembler = TransactionKernel::assembler();

    for entry in fs::read_dir(source_dir)? {
        let path = entry?.path();
        if path.extension() == Some("masm".as_ref()) {
            compile_library(&assembler, &path, &target_dir)?;
        }
    }

    Ok(())
}
```

### 3. Implement AccountComponent Pattern

#### Example: LendingPoolAccount Component

```rust
// src/accounts/lending_pool.rs
use miden_objects::{
    account::{AccountComponent, StorageSlot},
    AccountError, Felt, Word,
};

pub struct LendingPoolAccount {
    // Reserve configuration
    usdc_reserve_data: Word,
    dai_reserve_data: Word,
    weth_reserve_data: Word,
}

impl From<LendingPoolAccount> for AccountComponent {
    fn from(pool: LendingPoolAccount) -> Self {
        AccountComponent::new(
            lending_pool_library(),  // Compiled MASM library
            vec![
                StorageSlot::Value(pool.usdc_reserve_data),
                StorageSlot::Value(pool.dai_reserve_data),
                StorageSlot::Value(pool.weth_reserve_data),
            ]
        )
        .expect("lending pool component should be valid")
        .with_supported_type(AccountType::RegularAccountUpdatableCode)
    }
}

// Account builder function
pub fn create_lending_pool_builder(
    init_seed: [u8; 32],
    storage_mode: AccountStorageMode,
) -> Result<AccountBuilder, AccountError> {
    Ok(AccountBuilder::new(init_seed)
        .account_type(AccountType::RegularAccountUpdatableCode)
        .storage_mode(storage_mode)
        .with_component(LendingPoolAccount {
            usdc_reserve_data: Word::default(),
            dai_reserve_data: Word::default(),
            weth_reserve_data: Word::default(),
        }))
}
```

### 4. Integration Tests with MockChain

```rust
// tests/integration_tests.rs
use miden_testing::{MockChain, Auth, AccountState};
use miden_objects::{
    account::AccountId,
    asset::FungibleAsset,
    transaction::TransactionScript,
};

#[test]
fn test_deposit_withdraw_with_mockchain() -> anyhow::Result<()> {
    // Create mock chain
    let mut mock_chain_builder = MockChain::builder();

    // Create lending pool account
    let pool_builder = create_lending_pool_builder(
        [1; 32],
        AccountStorageMode::Public,
    )?;

    let mut pool = mock_chain_builder.add_account_from_builder(
        Auth::NoAuth,
        pool_builder,
        AccountState::Exists,
    )?;

    let mut mock_chain = mock_chain_builder.build()?;

    // Create deposit transaction
    let tx_script = ScriptBuilder::default()
        .compile_tx_script("
            begin
                push.1000  # amount
                push.1     # asset_id
                call.lending_pool::deposit
            end
        ")?;

    // Execute transaction
    let tx_inputs = mock_chain.get_transaction_inputs(
        pool.clone(),
        None,
        &[],
        &[]
    )?;

    let executed_tx = mock_chain
        .build_tx_context(pool.clone(), &[], &[])?
        .tx_script(tx_script)
        .tx_inputs(tx_inputs)
        .build()?
        .execute_blocking()?;

    // Verify results
    assert!(executed_tx.account_delta().is_some());

    Ok(())
}
```

### 5. MASM Account Component Example

```masm
# src/asm/contracts/lending_pool.masm
# Lending Pool Account Component

use.miden::contracts::faucets::basic_fungible

# Storage layout:
# slot 0: USDC reserve data [total_liquidity, total_borrowed, liquidity_rate, borrow_rate]
# slot 1: DAI reserve data
# slot 2: WETH reserve data

export.deposit
    # Input: [amount, asset_id]
    # Output: [success]

    # Load current reserve data
    push.0 mem_loadw  # Load slot 0 (USDC)

    # Update total_liquidity
    dup.3 add         # total_liquidity += amount

    # Store updated reserve data
    push.0 mem_storew

    push.1  # success
end

export.get_reserve_data
    # Input: [asset_id]
    # Output: [total_liquidity, total_borrowed, liquidity_rate, borrow_rate]

    # Load reserve data based on asset_id
    push.0 mem_loadw
end
```

## Key Differences from Current Implementation

### Current (Stub) Implementation:
- ❌ Using custom AccountId wrapper
- ❌ Mock transaction execution
- ❌ No actual account storage
- ❌ No MASM compilation

### Proper Miden Implementation:
- ✅ Use `miden-objects::account::AccountId` directly
- ✅ Real transaction execution with Miden VM
- ✅ Actual account storage in Miden format
- ✅ MASM code compiled to MASL libraries
- ✅ Integration tests with MockChain
- ✅ AccountComponent pattern for modularity

## Migration Path

1. **Phase 1**: Update dependencies and add build.rs
2. **Phase 2**: Create MASM files in src/asm/
3. **Phase 3**: Implement AccountComponent wrappers
4. **Phase 4**: Update integration tests to use MockChain
5. **Phase 5**: Remove stub implementations

## Additional Resources

- Miden Bridge Example: `/Users/salman/Limo-tools/miden-bridge-mono/miden`
- Miden Documentation: https://docs.polygon.technology/miden/
- Miden GitHub: https://github.com/0xPolygonMiden/miden-base

## Next Steps

1. Review existing MASM files in `../accounts/*.masm`
2. Create proper AccountComponent wrappers
3. Add build.rs to compile MASM
4. Update tests to use MockChain
5. Implement actual transaction execution

---

**Note**: This is a significant refactoring that will make the implementation production-ready by using actual Miden VM execution instead of stubs.
