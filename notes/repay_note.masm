# ===================================================================================================
# Repay Note Script
# ===================================================================================================
# This note script allows users to repay borrowed assets to the lending pool.
# It burns debt tokens and reduces the user's outstanding debt.

use.miden::account
use.miden::note
use.miden::tx

# Note metadata constants
const.REPAY_NOTE_TYPE=4

# ===================================================================================================
# REPAY NOTE MAIN
# This is the main entry point executed when the note is consumed
#
# Expected note inputs:
# - Asset ID being repaid
# - Amount to repay
# - Borrower account ID
# - Debt token amount to burn
#
# Stack input: []
# Stack output: []
# ===================================================================================================
begin
    # Get note inputs
    exec.note::get_inputs
    # Stack: [borrower_account_id, asset_id, repay_amount, debt_token_amount, ...]

    # Verify note is consumed by lending pool
    exec.validate_consumer

    # Verify repayment amount matches debt token amount
    # (accounting for accrued interest)
    exec.verify_repay_amount

    # Add repaid assets to pool vault
    exec.add_repayment_to_pool

    # Update pool state (decrease total borrowed)
    exec.update_pool_repay_state

    # Burn debt tokens
    exec.burn_debt_tokens

    # Create confirmation note for borrower
    exec.create_repayment_confirmation
end

# ===================================================================================================
# VALIDATE CONSUMER
# Ensures the note is consumed by the authorized lending pool
# Stack input: [borrower_account_id, asset_id, repay_amount, debt_token_amount]
# Stack output: [borrower_account_id, asset_id, repay_amount, debt_token_amount]
# ===================================================================================================
proc.validate_consumer
    # Stack: [borrower_account_id, asset_id, repay_amount, debt_token_amount]

    exec.account::get_id
    # Stack: [consumer_account_id, borrower_account_id, asset_id, repay_amount, debt_token_amount]

    # Verify consumer is lending pool
    dup.0
    push.0
    neq
    assert

    drop
    # Stack: [borrower_account_id, asset_id, repay_amount, debt_token_amount]
end

# ===================================================================================================
# VERIFY REPAY AMOUNT
# Verifies that repayment amount is valid for the debt being repaid
# Stack input: [borrower_account_id, asset_id, repay_amount, debt_token_amount]
# Stack output: [borrower_account_id, asset_id, repay_amount, actual_debt]
# ===================================================================================================
proc.verify_repay_amount
    # Stack: [borrower_account_id, asset_id, repay_amount, debt_token_amount]

    # Calculate actual debt including accrued interest
    # actual_debt = debt_token_amount * borrow_index / initial_index

    # For simplicity, assume 1:1 for now
    # In production, this would:
    # 1. Get current borrow index for asset
    # 2. Get user's initial borrow index
    # 3. Calculate: debt_token_amount * current_index / initial_index

    dup.3  # debt_token_amount
    # Stack: [actual_debt, borrower_account_id, asset_id, repay_amount, debt_token_amount]

    # Verify repay_amount <= actual_debt
    dup.3  # repay_amount
    dup.1  # actual_debt
    lte
    assert
    # Stack: [actual_debt, borrower_account_id, asset_id, repay_amount, debt_token_amount]

    # Replace debt_token_amount with actual_debt on stack
    swap.4
    drop
    swap.3
    # Stack: [borrower_account_id, asset_id, repay_amount, actual_debt]
end

# ===================================================================================================
# ADD REPAYMENT TO POOL
# Adds the repaid assets to the pool's vault
# Stack input: [borrower_account_id, asset_id, repay_amount, actual_debt]
# Stack output: [borrower_account_id, asset_id, repay_amount, actual_debt]
# ===================================================================================================
proc.add_repayment_to_pool
    # Stack: [borrower_account_id, asset_id, repay_amount, actual_debt]

    # The assets in this note are automatically available
    # They will be added to the pool's vault when note is consumed

    # Verify the note contains the correct asset amount
    # This is handled by Miden's note consumption mechanism

    # No stack changes
    # Stack: [borrower_account_id, asset_id, repay_amount, actual_debt]
end

# ===================================================================================================
# UPDATE POOL REPAY STATE
# Updates pool's total borrowed amount and interest rates
# Stack input: [borrower_account_id, asset_id, repay_amount, actual_debt]
# Stack output: [borrower_account_id, asset_id, repay_amount, actual_debt]
# ===================================================================================================
proc.update_pool_repay_state
    # Stack: [borrower_account_id, asset_id, repay_amount, actual_debt]

    # Call lending pool's repayment tracking function
    # This reduces TOTAL_BORROWED and recalculates interest rates

    # Prepare stack for pool function call
    # Expected: [repay_amount, asset_id]
    dup.2  # repay_amount
    dup.2  # asset_id
    # Stack: [asset_id, repay_amount, borrower_account_id, asset_id, repay_amount, actual_debt]

    # In practice: exec.lending_pool::record_repayment
    # This would:
    # 1. Get current TOTAL_BORROWED for asset
    # 2. Subtract repay_amount
    # 3. Update storage
    # 4. Recalculate interest rates

    drop
    drop
    # Stack: [borrower_account_id, asset_id, repay_amount, actual_debt]
end

# ===================================================================================================
# BURN DEBT TOKENS
# Burns the debt tokens corresponding to the repaid amount
# Stack input: [borrower_account_id, asset_id, repay_amount, actual_debt]
# Stack output: [borrower_account_id, asset_id, repay_amount, actual_debt]
# ===================================================================================================
proc.burn_debt_tokens
    # Stack: [borrower_account_id, asset_id, repay_amount, actual_debt]

    # Calculate debt tokens to burn
    # debt_tokens_to_burn = repay_amount (simplified 1:1)

    # In production:
    # 1. Calculate debt tokens based on current borrow index
    # 2. Update borrower's debt token balance
    # 3. Emit burn event

    # The debt tokens would be tracked in borrower's account
    # This note signals to the borrower to update their debt tracking

    # No stack changes
    # Stack: [borrower_account_id, asset_id, repay_amount, actual_debt]
end

# ===================================================================================================
# CREATE REPAYMENT CONFIRMATION
# Creates output note confirming the repayment for the borrower
# Stack input: [borrower_account_id, asset_id, repay_amount, actual_debt]
# Stack output: []
# ===================================================================================================
proc.create_repayment_confirmation
    # Stack: [borrower_account_id, asset_id, repay_amount, actual_debt]

    # Create confirmation note for borrower
    # This note tells the borrower:
    # - How much was repaid
    # - Remaining debt (if any)
    # - Updated health factor

    # Calculate remaining debt
    dup.3  # actual_debt
    dup.3  # repay_amount
    sub
    # Stack: [remaining_debt, borrower_account_id, asset_id, repay_amount, actual_debt]

    # In practice: exec.tx::create_note with:
    # - Recipient: borrower_account_id
    # - Metadata: repayment details
    # - No assets (just information)

    # Clean up stack
    drop
    drop
    drop
    drop
    drop
    # Stack: []
end
